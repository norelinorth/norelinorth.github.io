---
layout: post
title: "Make Your Month-End Close AI Automation 100x Better - Monitor Every AI Agent Decision with Langfuse"
description: "Build production-ready AI agents that automate ERPNext month-end close with complete observability. Learn how to integrate LangChain, ERPNext, and Langfuse for intelligent financial automation with full traceability."
date: 2025-10-27
author: "Noreli North"
categories: [AI, ERPNext, Financial Automation, LangChain, Observability]
tags: [Langfuse, ERPNext, AI Agents, LangChain, Financial Close, Month-End Close, Observability, Production AI, Frappe Framework, Accounting Automation]
---

**Key Results:**
- âš¡ **ERP Month-End Close Automation**
- ğŸ” **100% observability**
- ğŸ¯ **47 tool executions**
- âœ… **Zero manual debugging**
- ğŸ“Š **Real-time cost tracking**
- ğŸš€ **Production-ready from day 1**

[Video Tutorial](https://youtu.be/O_RaNvtAr6g) | [Blog](https://norelinorth.github.io)

---

## Table of Contents

1. [The Problem: Manual Month-End Close](#the-problem)
2. [The Solution: AI Agents + Observability](#the-solution)
3. [Architecture Overview](#architecture)
4. [Example 1: Pre-Close Checklist Agent](#example-1)
5. [Example 2: Full Month-End Close Agent](#example-2)
6. [Langfuse Integration](#langfuse-integration)
7. [Setup Guide](#setup)
8. [Production Considerations](#production)
9. [Next Steps](#next-steps)

---

<a name="the-problem"></a>
## The Problem: Manual Month-End Close

If you're running ERPNext for multi-entity accounting, you know the pain of month-end close:

### Typical Timeline:
- **Day 1-2**: Pre-close validation
  - Check all invoices submitted
  - Verify payment reconciliation
  - Identify outstanding items
  - Review pending approvals

- **Day 3**: Bank reconciliation
  - Match bank statements
  - Identify discrepancies
  - Create adjustment entries

- **Day 4**: Financial statement preparation
  - Generate P&L
  - Generate Balance Sheet
  - Calculate financial ratios
  - Review for accuracy

- **Day 5**: Intercompany reconciliation & final review
  - Match intercompany transactions
  - Create elimination entries
  - Final review and sign-off

### The Cost:
- **3-5 days** of senior accounting staff time **every month**
- **36-60 days per year** spent on repetitive procedures
- **High error risk** due to manual data entry and calculations
- **Cannot scale** without hiring proportionally more accountants

### Why Traditional Automation Fails:
- **Brittle scripts**: Break when chart of accounts changes
- **No intelligence**: Can't handle exceptions or unusual cases
- **No observability**: When errors occur, debugging is manual
- **Siloed tools**: Different scripts for different procedures

**What if you could automate this intelligently with AI agents AND monitor every decision they make?**

---

<a name="the-solution"></a>
## The Solution: AI Agents + Observability

### What I Built

An AI agent framework that:

1. **Automates financial close workflows** using LangChain and ERPNext APIs
2. **Adapts intelligently** to different company structures and data conditions
3. **Provides complete observability** via Langfuse tracing
4. **Integrates seamlessly** with ERPNext's AI Assistant settings

### Key Results

**Pre-Close Checklist**:
```
Input:  Company + Period
Output: Complete validation report in ~30 seconds
        - Invoice status (submitted/draft/cancelled)
        - Payment reconciliation status
        - Outstanding receivables/payables with aging
        - Pending approvals by document type and amount
        - Actionable items with priority
```

**Full Month-End Close**:
```
Input:  Company + Period
Output: Complete financial close report in ~5 minutes
        - All pre-close validation items
        - Bank reconciliation summary
        - Financial statements (P&L, Balance Sheet)
        - Financial ratios (Current Ratio, D/E, ROA, etc.)
        - Intercompany reconciliation status
        - Executive summary with key insights
```

### The Differentiation

- âœ… **Real accounting workflows**
- âœ… **Production ERPNext integration** (actual Frappe API calls)
- âœ… **Complete observability** (every API call, every decision traced)
- âœ… **Handles complexity** (parallel execution, error handling, data validation)

---

<a name="architecture"></a>
## Architecture Overview

### Component Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    AI Agent Framework                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  RunnableSequence (LangChain)                            â”‚   â”‚
â”‚  â”‚  - Orchestrates workflow execution                       â”‚   â”‚
â”‚  â”‚  - Manages dependencies between steps                    â”‚   â”‚
â”‚  â”‚  - Handles parallel vs sequential execution              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                           â”‚                                     â”‚
â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚            â”‚              â”‚              â”‚                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Runnable         â”‚ â”‚  Runnable    â”‚  â”‚  RunnableLambda  â”‚    â”‚
â”‚  â”‚ ParallelAgent    â”‚ â”‚  Sequential  â”‚  â”‚  (ERPNext Tools) â”‚    â”‚
â”‚  â”‚                  â”‚ â”‚  Agent       â”‚  â”‚                  â”‚    â”‚
â”‚  â”‚ - Invoice checks â”‚ â”‚  - Ordered   â”‚  â”‚  - Frappe API    â”‚    â”‚
â”‚  â”‚ - Payment checks â”‚ â”‚    workflow  â”‚  â”‚  - GL queries    â”‚    â”‚
â”‚  â”‚ - Outstanding    â”‚ â”‚  - Financial â”‚  â”‚  - DocType CRUD  â”‚    â”‚
â”‚  â”‚   items          â”‚ â”‚    stmts     â”‚  â”‚  - Reports       â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                           â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  ChatOpenAI + ChatPromptTemplate                          â”‚  â”‚
â”‚  â”‚  - LLM decision-making layer                              â”‚  â”‚
â”‚  â”‚  - Interprets data and composes reports                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                           â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Langfuse CallbackHandler                                 â”‚  â”‚
â”‚  â”‚  - Traces every step                                      â”‚  â”‚
â”‚  â”‚  - Captures tool calls, inputs, outputs                   â”‚  â”‚
â”‚  â”‚  - Measures latency, tokens, cost                         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â”‚ Configuration from
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ERPNext: AI Assistant Settings (Single DocType)                â”‚
â”‚  - LLM Provider (OpenAI / Anthropic / Local)                    â”‚
â”‚  - API Keys (encrypted)                                         â”‚
â”‚  - Model parameters                                             â”‚
â”‚  - Langfuse configuration (Public Key, Secret Key, Host)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Design Decisions

#### 1. **Parallel vs Sequential Execution**

```python
# Parallel: Run simultaneously for speed
parallel_checks = RunnableParallel({
    "invoices": check_sales_invoices + check_purchase_invoices,
    "payments": check_payment_reconciliation,
    "outstanding": analyze_outstanding_items,
    "approvals": check_pending_approvals
})

# Sequential: Run in order when steps depend on each other
sequential_workflow = RunnableSequence([
    pre_close_validation,      # Must complete first
    bank_reconciliation,        # Depends on pre-close
    financial_statements,       # Depends on bank rec
    intercompany_reconciliation, # Depends on financial stmts
    final_report_composition    # Depends on all above
])
```

**Why this matters**:
- Parallel execution cuts pre-close validation time from 2 minutes to 30 seconds
- Sequential execution ensures data consistency (no race conditions)

#### 2. **ERPNext Integration via RunnableLambda**

```python
class ERPNextTool(RunnableLambda):
    """Bridge between LangChain and ERPNext/Frappe"""

    def __init__(self, doctype: str, method: str):
        self.doctype = doctype
        self.method = method
        super().__init__(self._execute)

    def _execute(self, inputs: dict) -> dict:
        """Execute Frappe API call"""
        return frappe.get_all(
            self.doctype,
            filters=inputs.get("filters", {}),
            fields=inputs.get("fields", ["name"]),
            order_by=inputs.get("order_by", "creation desc"),
            limit=inputs.get("limit", 100)
        )

# Usage in agent
check_invoices_tool = ERPNextTool(
    doctype="Sales Invoice",
    method="get_all"
)
```

**Why this approach**:
- Clean separation of concerns (agent logic vs ERPNext API)
- Easy to mock for testing
- Automatically traced by Langfuse (it's a Runnable)

#### 3. **Centralized Configuration**

Rather than hardcoding credentials, I read from ERPNext settings:

```python
def initialize_agent():
    # Load from ERPNext Single DocType
    settings = frappe.get_single("AI Assistant Settings")

    # Configure Langfuse
    os.environ["LANGFUSE_PUBLIC_KEY"] = settings.langfuse_public_key
    os.environ["LANGFUSE_SECRET_KEY"] = settings.get_password("langfuse_secret_key")
    os.environ["LANGFUSE_HOST"] = settings.langfuse_host or "https://cloud.langfuse.com"

    # Configure LLM
    llm = ChatOpenAI(
        model=settings.model_name,
        temperature=settings.temperature,
        api_key=settings.get_password("api_key")
    )

    # Create Langfuse callback handler
    from langfuse.callback import CallbackHandler
    callback = CallbackHandler()

    return llm, callback
```

**Benefits**:
- No secrets in code
- Easy to switch between dev/prod
- Auditable (all changes tracked in ERPNext)

---

<a name="example-1"></a>
## Example 1: Pre-Close Checklist Agent

### What It Does

The Pre-Close Checklist agent validates that all prerequisites are met before attempting month-end close. It's the equivalent of a senior accountant's pre-close review checklist.

### Input

```python
{
    "company": "Noreli North (Demo)",
    "period": "October 2025",
    "date_range": {
        "from_date": "2025-10-01",
        "to_date": "2025-10-31"
    }
}
```

### Output

```
### Pre-Close Checklist for Noreli North (Demo) - October 2025

1. **Sales Invoices Status:**
   - Total Sales Invoices: 2
   - Submitted: 2 âœ“
   - Draft: 0 âœ“

2. **Purchase Invoices Status:**
   - Total Purchase Invoices: 4
   - Submitted: 3
   - Draft: 1 âš ï¸
     - Action Required: Submit draft purchase invoice "ACC-PINV-2025-00012" ($500.00)

3. **Payment Reconciliation:**
   - All payments are reconciled. âœ“

4. **Outstanding Items:**
   - Outstanding Receivables:
     - Total Amount: $91,800.00
     - Overdue Amount: $89,400.00
     - Top Customer: Grant Plastics Ltd.

   - Outstanding Payables:
     - Total Amount: $185,593.00
     - Overdue Amount: $185,593.00
     - Top Supplier: Summit Traders Ltd.

5. **Pending Approvals:**
   - Total Pending Approvals: 46
   - Total Amount: $21,111,411.00
   - Documents Affected: 3 DocTypes

### Summary:
- **Overall Readiness Status:** Not Ready âš ï¸
- **Issues Requiring Attention:** 1
- **Estimated Time to Resolve:** Immediate (< 5 minutes)
- **Priority Action Item:**
  - Submit draft purchase invoice "ACC-PINV-2025-00012" ($500.00)
```

### Agent Implementation

```python
from langchain.schema.runnable import RunnableParallel, RunnableSequence
from langchain.chat_models import ChatOpenAI
from langchain.prompts import ChatPromptTemplate

def create_pre_close_checklist_agent(company: str, period: dict):
    """
    Creates an agent that performs pre-close validation checks
    """
    llm, langfuse_callback = initialize_agent()

    # Define parallel checks (run simultaneously)
    parallel_checks = RunnableParallel({
        "sales_invoices": check_sales_invoices_tool,
        "purchase_invoices": check_purchase_invoices_tool,
        "payment_reconciliation": check_payment_reconciliation_tool,
        "outstanding_items": analyze_outstanding_items_tool,
        "pending_approvals": check_pending_approvals_tool
    })

    # Define report composition prompt
    report_prompt = ChatPromptTemplate.from_template("""
    You are a senior accountant reviewing pre-close checklist results.

    Based on the following data, create a comprehensive pre-close checklist report:

    Sales Invoices: {sales_invoices}
    Purchase Invoices: {purchase_invoices}
    Payment Reconciliation: {payment_reconciliation}
    Outstanding Items: {outstanding_items}
    Pending Approvals: {pending_approvals}

    Format the report with:
    1. Status for each check (âœ“ if good, âš ï¸ if attention needed)
    2. Specific action items if issues found
    3. Overall readiness assessment
    4. Priority ranking of issues

    Be specific: Include document numbers, amounts, and customer/supplier names.
    """)

    # Create sequential workflow
    agent = RunnableSequence([
        parallel_checks,           # Run all checks simultaneously
        report_prompt | llm        # Compose report with LLM
    ], callbacks=[langfuse_callback])

    # Execute agent
    result = agent.invoke({
        "company": company,
        "from_date": period["from_date"],
        "to_date": period["to_date"]
    })

    return result
```

### Langfuse Trace Analysis

When you run this agent and view the Langfuse trace, you see:

**Trace ID**: `bd990340e5278f55efc1b908d8139b49`

```
Pre-Close Checklist Agent
â”œâ”€â”€ RunnableParallel (30.2s total)
â”‚   â”œâ”€â”€ check_sales_invoices (8.1s)
â”‚   â”‚   â”œâ”€â”€ Tool Call: frappe.get_all
â”‚   â”‚   â”‚   â”œâ”€â”€ Input: {doctype: "Sales Invoice", filters: {...}}
â”‚   â”‚   â”‚   â””â”€â”€ Output: [{name: "ACC-SINV-2025-00007", ...}, ...]
â”‚   â”‚   â””â”€â”€ Result: 2 invoices, 2 submitted
â”‚   â”‚
â”‚   â”œâ”€â”€ check_purchase_invoices (12.4s)
â”‚   â”‚   â”œâ”€â”€ Tool Call: frappe.get_all
â”‚   â”‚   â”‚   â”œâ”€â”€ Input: {doctype: "Purchase Invoice", filters: {...}}
â”‚   â”‚   â”‚   â””â”€â”€ Output: [{name: "ACC-PINV-2025-00012", docstatus: 0}, ...]
â”‚   â”‚   â””â”€â”€ Result: 4 invoices, 3 submitted, 1 draft âš ï¸
â”‚   â”‚
â”‚   â”œâ”€â”€ check_payment_reconciliation (6.3s)
â”‚   â”œâ”€â”€ analyze_outstanding_items (15.8s)
â”‚   â””â”€â”€ check_pending_approvals (9.2s)
â”‚
â””â”€â”€ ChatOpenAI: Report Composition (4.1s)
    â”œâ”€â”€ Input Tokens: 2,847
    â”œâ”€â”€ Output Tokens: 542
    â”œâ”€â”€ Cost: $0.0124
    â””â”€â”€ Model: gpt-4-turbo
```

**Key Insights from Trace**:
1. **Parallel execution saved ~20 seconds** (vs running sequentially)
2. **Draft invoice identified** in `check_purchase_invoices` step
3. **Total cost**: $0.0124 (very economical)
4. **Total time**: 34.3 seconds

---

<a name="example-2"></a>
## Example 2: Full Month-End Close Agent

### What It Does

The Month-End Close agent performs the complete financial close procedure, including all validation, reconciliation, financial statement generation, and reporting.

### Input

```python
{
    "company": "Noreli North (Demo)",
    "period": "October 2025",
    "date_range": {
        "from_date": "2025-10-01",
        "to_date": "2025-10-31"
    },
    "bank_accounts": ["Demo Bank Account - NND"],
    "include_intercompany": True
}
```

### Output

```
### Month-End Close Summary for Noreli North (Demo) - October 2025

1. **Pre-Close Validation**
   - Invoices: All invoices are submitted. âœ“
   - Payment Reconciliation: All payments reconciled. âœ“

2. **Bank Reconciliation**
   - Bank Account: Demo Bank Account - NND
   - Reconciliation Status: Complete âœ“
   - Book Balance: $5,065,146.00
   - Bank Statement Balance: $5,065,146.00
   - Difference: $0.00

3. **Outstanding Items**
   - Receivables: $91,800.00 (Overdue: $89,400.00)
   - Payables: $185,593.00 (Overdue: $185,593.00)

4. **Pending Approvals**
   - Total Pending: 46 documents
   - Total Amount: $21,111,411.00

5. **Accrual Entries**
   - No accruals identified.
   - Verification: All invoices have correct accounting dimensions.

6. **Depreciation**
   - No active assets found for depreciation period.

7. **Financial Statements**

   **Profit & Loss Statement:**
   | Account | Amount |
   |---------|--------|
   | Revenue | $10,076,850.00 |
   | Cost of Goods Sold | $0.00 |
   | Gross Profit | $10,076,850.00 |
   | Operating Expenses | $104,250.00 |
   | **Net Profit** | **$9,972,600.00** |
   | **Profit Margin** | **98.97%** |

   **Balance Sheet:**
   | Category | Amount |
   |----------|--------|
   | Current Assets | $11,108,053.00 |
   | Fixed Assets | $93,200.00 |
   | **Total Assets** | **$11,201,253.00** |
   | Current Liabilities | $289,686.00 |
   | Long-term Liabilities | $89,200.00 |
   | **Total Liabilities** | **$378,886.00** |
   | Equity | $53,200.00 |
   | Retained Earnings | $10,769,167.00 |
   | **Total Equity** | **$10,822,367.00** |

   **Key Financial Ratios:**
   - Current Ratio: 38.36 (Excellent liquidity)
   - Debt-to-Equity Ratio: 7.12 (Moderate leverage)
   - Return on Assets (ROA): 89.03% (Outstanding performance)
   - Return on Equity (ROE): 92.14%

8. **Intercompany Reconciliation**
   - Status: Reconciliation attempted
   - Note: Counterparty company 'Noreli South' does not exist in system

### Overall Assessment:
âœ… **Month-end close procedures completed successfully**
âœ… **Financial statements generated and balanced**
âš ï¸ **Action Items:**
   - Review and resolve 46 pending approvals ($21.1M)
   - Follow up on overdue receivables ($89.4K)
   - Address intercompany setup for Noreli South

**Close Status**: COMPLETE
**Sign-off Ready**: Yes (with noted action items)
```

### Agent Implementation (Simplified)

```python
def create_month_end_close_agent(company: str, period: dict, bank_accounts: list):
    """
    Creates agent for complete month-end close workflow
    """
    llm, langfuse_callback = initialize_agent()

    # Step 1: Pre-close validation (from previous example)
    pre_close_agent = create_pre_close_checklist_agent(company, period)

    # Step 2: Bank reconciliation
    bank_rec_tool = ERPNextTool(doctype="Bank Reconciliation Tool", method="reconcile")

    # Step 3: Financial statements generation
    financial_statements_sequence = RunnableSequence([
        # Query GL for P&L accounts
        get_profit_loss_data,

        # Query GL for Balance Sheet accounts
        get_balance_sheet_data,

        # Calculate financial ratios
        calculate_financial_ratios,

        # Format into report
        format_financial_statements
    ])

    # Step 4: Intercompany reconciliation
    intercompany_tool = ERPNextTool(doctype="IC Match Group", method="run_matching")

    # Combine into complete workflow
    month_end_close_agent = RunnableSequence([
        {
            "pre_close": pre_close_agent,
            "bank_reconciliation": bank_rec_tool,
        },
        financial_statements_sequence,
        intercompany_tool,
        compose_final_report
    ], callbacks=[langfuse_callback])

    # Execute with metadata for Langfuse
    result = month_end_close_agent.invoke(
        {
            "company": company,
            "period": period,
            "bank_accounts": bank_accounts
        },
        config={
            "metadata": {
                "workflow": "month_end_close",
                "company": company,
                "period": f"{period['from_date']} to {period['to_date']}"
            }
        }
    )

    return result
```

### Langfuse Trace Analysis

**Trace ID**: `97c5a91fccf7071c947470497da6a1b5`

```
Month-End Close Agent (Total: 4m 52s)
â”œâ”€â”€ RunnableSequence: Complete Workflow
â”‚   â”‚
â”‚   â”œâ”€â”€ RunnableParallel: Pre-Close + Bank Rec (45.2s)
â”‚   â”‚   â”œâ”€â”€ Pre-Close Checklist Agent (34.3s)
â”‚   â”‚   â”‚   â””â”€â”€ [See detailed trace from Example 1]
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ Bank Reconciliation (28.7s)
â”‚   â”‚       â”œâ”€â”€ Tool: Get Bank Statement
â”‚   â”‚       â”œâ”€â”€ Tool: Get GL Entries for Bank Account
â”‚   â”‚       â”œâ”€â”€ Tool: Match Transactions
â”‚   â”‚       â””â”€â”€ Result: Reconciled âœ“
â”‚   â”‚
â”‚   â”œâ”€â”€ RunnableSequence: Financial Statements (3m 48s)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Get Profit & Loss Data (52.1s)
â”‚   â”‚   â”‚   â”œâ”€â”€ Tool: frappe.db.sql (GL Entry query for revenue)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Query: SELECT account, SUM(credit-debit) FROM...
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ Result: 18 revenue accounts, $10.08M total
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â””â”€â”€ Tool: frappe.db.sql (GL Entry query for expenses)
â”‚   â”‚   â”‚       â”œâ”€â”€ Query: SELECT account, SUM(debit-credit) FROM...
â”‚   â”‚   â”‚       â””â”€â”€ Result: 7 expense accounts, $104.3K total
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Get Balance Sheet Data (1m 18.4s)
â”‚   â”‚   â”‚   â”œâ”€â”€ Tool: Query Assets
â”‚   â”‚   â”‚   â”œâ”€â”€ Tool: Query Liabilities
â”‚   â”‚   â”‚   â””â”€â”€ Tool: Query Equity
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Calculate Financial Ratios (8.2s)
â”‚   â”‚   â”‚   â”œâ”€â”€ Current Ratio: 38.36
â”‚   â”‚   â”‚   â”œâ”€â”€ Debt-to-Equity: 7.12
â”‚   â”‚   â”‚   â””â”€â”€ ROA: 89.03%
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ Format Financial Statements (1m 29.3s)
â”‚   â”‚       â”œâ”€â”€ ChatOpenAI: Generate P&L narrative
â”‚   â”‚       â”‚   â”œâ”€â”€ Input Tokens: 4,182
â”‚   â”‚       â”‚   â”œâ”€â”€ Output Tokens: 827
â”‚   â”‚       â”‚   â””â”€â”€ Cost: $0.0187
â”‚   â”‚       â”‚
â”‚   â”‚       â””â”€â”€ ChatOpenAI: Generate Balance Sheet narrative
â”‚   â”‚           â”œâ”€â”€ Input Tokens: 3,641
â”‚   â”‚           â”œâ”€â”€ Output Tokens: 694
â”‚   â”‚           â””â”€â”€ Cost: $0.0164
â”‚   â”‚
â”‚   â”œâ”€â”€ Intercompany Reconciliation (18.7s)
â”‚   â”‚   â”œâ”€â”€ Tool: Find Intercompany Transactions
â”‚   â”‚   â””â”€â”€ Result: Counterparty not found (Noreli South)
â”‚   â”‚
â”‚   â””â”€â”€ Compose Final Report (1m 0.0s)
â”‚       â”œâ”€â”€ ChatOpenAI: Executive Summary
â”‚       â”‚   â”œâ”€â”€ Input Tokens: 6,842
â”‚       â”‚   â”œâ”€â”€ Output Tokens: 1,204
â”‚       â”‚   â”œâ”€â”€ Cost: $0.0311
â”‚       â”‚   â””â”€â”€ Model: gpt-4-turbo
â”‚       â”‚
â”‚       â””â”€â”€ Output: Complete Month-End Close Report
â”‚
â””â”€â”€ Metadata
    â”œâ”€â”€ Total Tool Calls: 47
    â”œâ”€â”€ Total Tokens: 18,934 (Input: 15,667, Output: 3,267)
    â”œâ”€â”€ Total Cost: $0.0876
    â”œâ”€â”€ Total Duration: 4m 52s
    â””â”€â”€ Status: SUCCESS âœ“
```

### Key Insights from Complex Trace

1. **Parallel execution** (Pre-Close + Bank Rec) saved significant time
2. **Most expensive step**: Financial statements composition ($0.0311)
3. **Most time-consuming step**: Financial statements (3m 48s)
4. **Optimization opportunity**: Could cache GL queries if running multiple times
5. **Error handling visible**: Intercompany reconciliation gracefully handled missing counterparty

---

<a name="langfuse-integration"></a>
## Langfuse Integration: How It Works

### Step 1: Configure ERPNext AI Assistant Settings

Create/update the `AI Assistant Settings` Single DocType with Langfuse fields:

**ai_assistant_settings.json** (DocType definition):
```json
{
    "doctype": "DocType",
    "name": "AI Assistant Settings",
    "issingle": 1,
    "fields": [
        {
            "fieldname": "langfuse_section",
            "label": "Langfuse Observability",
            "fieldtype": "Section Break"
        },
        {
            "fieldname": "enable_langfuse",
            "label": "Enable Langfuse Tracing",
            "fieldtype": "Check",
            "default": 1
        },
        {
            "fieldname": "langfuse_public_key",
            "label": "Langfuse Public Key",
            "fieldtype": "Data",
            "mandatory_depends_on": "enable_langfuse"
        },
        {
            "fieldname": "langfuse_secret_key",
            "label": "Langfuse Secret Key",
            "fieldtype": "Password",
            "mandatory_depends_on": "enable_langfuse"
        },
        {
            "fieldname": "langfuse_host",
            "label": "Langfuse Host",
            "fieldtype": "Data",
            "default": "https://cloud.langfuse.com",
            "description": "Use https://cloud.langfuse.com for cloud, or your self-hosted URL"
        }
    ]
}
```

### Step 2: Load Configuration in Agent

**agent_config.py**:
```python
import os
import frappe
from typing import Tuple
from langchain.chat_models import ChatOpenAI
from langfuse.callback import CallbackHandler

def get_ai_config() -> Tuple[ChatOpenAI, CallbackHandler]:
    """
    Load AI configuration from ERPNext settings
    Returns LLM instance and Langfuse callback handler
    """
    # Load Single DocType
    settings = frappe.get_single("AI Assistant Settings")

    if not settings.enable_langfuse:
        frappe.throw("Langfuse tracing is disabled in AI Assistant Settings")

    # Configure Langfuse environment
    os.environ["LANGFUSE_PUBLIC_KEY"] = settings.langfuse_public_key
    os.environ["LANGFUSE_SECRET_KEY"] = settings.get_password("langfuse_secret_key")
    os.environ["LANGFUSE_HOST"] = settings.langfuse_host

    # Initialize callback handler
    callback = CallbackHandler(
        # Optional: Add custom metadata
        tags=["erpnext", "financial-close"],
        session_id=frappe.session.user,
        user_id=frappe.session.user
    )

    # Initialize LLM
    llm = ChatOpenAI(
        model=settings.model_name or "gpt-4-turbo",
        temperature=settings.temperature or 0.1,
        api_key=settings.get_password("openai_api_key")
    )

    return llm, callback
```

### Step 3: Instrument Your Agent

**month_end_close_agent.py**:
```python
from langchain.schema.runnable import RunnableSequence, RunnableParallel
from agent_config import get_ai_config

def run_month_end_close(company: str, period: dict):
    """
    Execute month-end close with Langfuse tracing
    """
    # Get configured LLM and callback
    llm, langfuse_callback = get_ai_config()

    # Define your agent workflow
    agent = RunnableSequence([
        # ... your agent steps here ...
    ], callbacks=[langfuse_callback])  # â† This enables tracing!

    # Execute with metadata
    result = agent.invoke(
        {"company": company, "period": period},
        config={
            "metadata": {
                "workflow": "month_end_close",
                "company": company,
                "user": frappe.session.user
            },
            "tags": ["month-end-close", company]
        }
    )

    return result
```

### Step 4: View Traces in Langfuse

1. Run your agent
2. Log into Langfuse (cloud or self-hosted)
3. Navigate to **Traces** tab
4. Filter by:
   - Tags: `["erpnext", "month-end-close"]`
   - User: `frappe.session.user`
   - Time range: Last hour

You'll see:
- Complete execution tree
- Every tool call with inputs/outputs
- Token usage and costs per step
- Latency measurements
- Error traces (if any failures)

---

<a name="setup"></a>
## Setup Guide

### Prerequisites

- ERPNext v15+ (Frappe v15+)
- Python 3.10+
- OpenAI API key (or other LLM provider)
- Langfuse account (free tier available)

### Installation Steps

#### 1. Install Dependencies

```bash
# Navigate to your Frappe bench
cd frappe-bench

# Install Python packages
./env/bin/pip install langchain langchain-openai langfuse openai

# Or add to your app's requirements.txt
echo "langchain>=0.1.0" >> apps/your_app/requirements.txt
echo "langchain-openai>=0.0.5" >> apps/your_app/requirements.txt
echo "langfuse>=2.0.0" >> apps/your_app/requirements.txt
```

#### 2. Configure AI Assistant Settings

```bash
# Create the Single DocType (if not exists)
bench --site your-site migrate

# Set up Langfuse in ERPNext UI
# Navigate to: Settings â†’ AI Assistant Settings
```

Fill in:
- **Langfuse Public Key**: Get from https://cloud.langfuse.com/settings
- **Langfuse Secret Key**: Get from https://cloud.langfuse.com/settings
- **Langfuse Host**: `https://cloud.langfuse.com` (or your self-hosted URL)

#### 3. Install the AI Agent Framework

```bash
# Clone the repository
cd apps
git clone https://github.com/[your-username]/erpnext-ai-agents.git

# Install the app
cd ../sites
bench --site your-site install-app erpnext-ai-agents

# Migrate
bench --site your-site migrate
```

#### 4. Test the Integration

```python
# In bench console
bench --site your-site console

# Test configuration
from erpnext_ai_agents.agent_config import get_ai_config
llm, callback = get_ai_config()
print(f"LLM Model: {llm.model_name}")
print(f"Langfuse Enabled: {callback is not None}")

# Test Pre-Close Checklist
from erpnext_ai_agents.pre_close_checklist import run_pre_close_checklist
result = run_pre_close_checklist(
    company="Your Company Name",
    period={"from_date": "2025-10-01", "to_date": "2025-10-31"}
)
print(result)
```

#### 5. Verify in Langfuse

1. Go to https://cloud.langfuse.com/traces
2. You should see a new trace for your test execution
3. Click into it to see the full execution tree

---

<a name="production"></a>
## Production Considerations

### 1. Error Handling

Always wrap agent execution in try/except:

```python
import frappe
from langchain.schema.runnable import RunnableSequence

def run_month_end_close_safe(company: str, period: dict):
    """
    Production-ready month-end close with error handling
    """
    try:
        llm, callback = get_ai_config()
        agent = create_month_end_close_agent(company, period)

        result = agent.invoke(
            {"company": company, "period": period},
            config={"metadata": {"source": "production"}}
        )

        # Log success
        frappe.logger().info(f"Month-end close completed for {company}")

        return {"status": "success", "result": result}

    except Exception as e:
        # Log error to Frappe
        frappe.log_error(
            message=f"Month-end close failed: {str(e)}\n{frappe.get_traceback()}",
            title=f"AI Agent Error: {company}"
        )

        # Langfuse will also capture the error in the trace

        return {
            "status": "error",
            "error": str(e),
            "message": "Month-end close failed. See Error Log for details."
        }
```

### 2. Cost Management

Monitor LLM costs via Langfuse:

```python
# Set budget alerts in Langfuse dashboard
# Settings â†’ Cost Tracking â†’ Set Alert Threshold

# Or implement in code:
def check_monthly_cost_limit():
    """Check if approaching monthly budget"""
    # Query Langfuse API for current month costs
    # (Implementation left as exercise)
    pass
```

### 3. Rate Limiting

Implement rate limiting for production:

```python
import time
from functools import wraps

def rate_limit(max_calls_per_minute=10):
    """Decorator to rate limit agent executions"""
    last_called = {}

    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            now = time.time()
            company = kwargs.get("company", args[0])

            if company in last_called:
                elapsed = now - last_called[company]
                if elapsed < 60 / max_calls_per_minute:
                    wait_time = (60 / max_calls_per_minute) - elapsed
                    frappe.throw(f"Rate limit exceeded. Try again in {wait_time:.1f}s")

            last_called[company] = now
            return func(*args, **kwargs)

        return wrapper
    return decorator

@rate_limit(max_calls_per_minute=5)
def run_month_end_close(company: str, period: dict):
    # ... implementation ...
    pass
```

### 4. Monitoring & Alerts

Set up alerts for:

- **Agent failures**: Email when agent execution fails
- **Cost spikes**: Alert if daily cost exceeds threshold
- **Latency issues**: Alert if execution time > 10 minutes
- **Data anomalies**: Alert if financial ratios are outside expected range

Example alert configuration in Langfuse:

```yaml
alerts:
  - name: "Month-End Close Failed"
    condition: "trace.status == 'ERROR' AND 'month-end-close' in trace.tags"
    action: "email"
    recipients: ["finance@company.com", "devops@company.com"]

  - name: "High Cost Warning"
    condition: "trace.cost > 1.00"
    action: "slack"
    channel: "#ai-monitoring"
```

### 5. Data Privacy

For sensitive financial data:

**Option 1**: Self-host Langfuse
```bash
# Use Docker Compose
git clone https://github.com/langfuse/langfuse
cd langfuse
docker-compose up -d

# Update AI Assistant Settings
Langfuse Host: https://your-internal-langfuse.company.com
```

**Option 2**: Mask sensitive data before logging
```python
def mask_sensitive_data(data: dict) -> dict:
    """Mask account numbers and customer names"""
    if "account" in data:
        data["account"] = data["account"][:4] + "****"
    if "customer_name" in data:
        data["customer_name"] = "***MASKED***"
    return data

# Apply before sending to Langfuse
# (Advanced: Use custom callback handler)
```

---

<a name="next-steps"></a>
## Next Steps

### Immediate Actions

**Watch the video tutorial**: [[YouTube link](https://youtu.be/O_RaNvtAr6g)]


### Coming in Part 3: Natural Language Queries

```python
# Instead of writing SQL:
query = "Show me all overdue receivables over $10,000 for Q4 2025"

# Agent handles it:
result = nl_query_agent.invoke(query)
# Returns: Formatted table with matching records
```

### Coming in Part 4: Autonomous Scheduling

```python
# Schedule month-end close to run automatically
schedule = {
    "workflow": "month_end_close",
    "frequency": "monthly",
    "day_of_month": 1,  # 1st of every month
    "time": "08:00",
    "companies": ["Company A", "Company B"],
    "notify": ["cfo@company.com", "controller@company.com"]
}
```

### Coming in Part 5: Multi-Company Consolidation

```python
# Run month-end close for all subsidiaries + consolidation
result = multi_company_close_agent.invoke({
    "parent_company": "Holding Corp",
    "subsidiaries": ["Sub A", "Sub B", "Sub C"],
    "eliminate_intercompany": True,
    "generate_consolidated_statements": True
})
```

---

## Resources

- **ğŸ“¹ Video Tutorial**: https://youtu.be/O_RaNvtAr6g
- **ğŸ“– Langfuse Documentation**: https://langfuse.com/docs
- **ğŸ“– ERPNext Documentation**: https://docs.erpnext.com

---

## FAQ

**Q: Does this work with self-hosted Langfuse?**
A: Yes! Just set the Langfuse Host in AI Assistant Settings to your self-hosted URL.

**Q: What LLM models are supported?**
A: OpenAI (GPT-4, GPT-3.5), Anthropic (Claude), and any OpenAI-compatible endpoint (local models via Ollama, etc.)

**Q: How much does it cost to run?**
A: For the examples shown:
- Pre-Close Checklist: ~$0.012 per execution
- Full Month-End Close: ~$0.088 per execution

With GPT-4-turbo. Costs are ~10x lower with GPT-3.5-turbo or local models.

**Q: Is this production-ready?**
A: Yes, with proper error handling, rate limiting, and monitoring (covered in Production Considerations section).

**Q: Can I customize the workflows?**
A: Absolutely! The framework is designed to be extended. Add your own tools, modify prompts, adjust the sequence.

**Q: What about data privacy?**
A: Use self-hosted Langfuse for complete data privacy, or implement data masking before logging (see Production Considerations).

---

## Contributing

I welcome contributions! Areas for improvement:

- [ ] Additional financial close checks (accruals, depreciation, etc.)
- [ ] Support for more ERP modules (inventory, manufacturing)
- [ ] Multi-language support (prompts in Spanish, German, etc.)
- [ ] Pre-built report templates
- [ ] Integration with other accounting systems
- [ ] Performance optimizations

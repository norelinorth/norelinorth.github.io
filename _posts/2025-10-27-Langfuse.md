---
layout: post
title: "Make Your Month-End Close AI Automation 100x Better - Monitor Every AI Agent Decision with Langfuse"
description: "Build production-ready AI agents that automate ERPNext month-end close with complete observability. Learn how to integrate LangChain, ERPNext, and Langfuse for intelligent financial automation with full traceability."
date: 2025-10-27
author: "Noreli North"
categories: [AI, ERPNext, Financial Automation, LangChain, Observability]
tags: [Langfuse, ERPNext, AI Agents, LangChain, Financial Close, Month-End Close, Observability, Production AI, Frappe Framework, Accounting Automation]
---

**Key Results:**
- ⚡ **ERP Month-End Close Automation**
- 🔍 **100% observability**
- 🎯 **47 tool executions**
- ✅ **Zero manual debugging**
- 📊 **Real-time cost tracking**
- 🚀 **Production-ready from day 1**

[Video Tutorial](https://youtu.be/O_RaNvtAr6g) | [Blog](https://norelinorth.github.io)

---

## Table of Contents

1. [The Problem: Manual Month-End Close](#the-problem)
2. [The Solution: AI Agents + Observability](#the-solution)
3. [Architecture Overview](#architecture)
4. [Example 1: Pre-Close Checklist Agent](#example-1)
5. [Example 2: Full Month-End Close Agent](#example-2)
6. [Langfuse Integration](#langfuse-integration)
7. [Setup Guide](#setup)
8. [Production Considerations](#production)
9. [Next Steps](#next-steps)

---

<a name="the-problem"></a>
## The Problem: Manual Month-End Close

If you're running ERPNext for multi-entity accounting, you know the pain of month-end close:

### Typical Timeline:
- **Day 1-2**: Pre-close validation
  - Check all invoices submitted
  - Verify payment reconciliation
  - Identify outstanding items
  - Review pending approvals

- **Day 3**: Bank reconciliation
  - Match bank statements
  - Identify discrepancies
  - Create adjustment entries

- **Day 4**: Financial statement preparation
  - Generate P&L
  - Generate Balance Sheet
  - Calculate financial ratios
  - Review for accuracy

- **Day 5**: Intercompany reconciliation & final review
  - Match intercompany transactions
  - Create elimination entries
  - Final review and sign-off

### The Cost:
- **3-5 days** of senior accounting staff time **every month**
- **36-60 days per year** spent on repetitive procedures
- **High error risk** due to manual data entry and calculations
- **Cannot scale** without hiring proportionally more accountants

### Why Traditional Automation Fails:
- **Brittle scripts**: Break when chart of accounts changes
- **No intelligence**: Can't handle exceptions or unusual cases
- **No observability**: When errors occur, debugging is manual
- **Siloed tools**: Different scripts for different procedures

**What if you could automate this intelligently with AI agents AND monitor every decision they make?**

---

<a name="the-solution"></a>
## The Solution: AI Agents + Observability

### What I Built

An AI agent framework that:

1. **Automates financial close workflows** using LangChain and ERPNext APIs
2. **Adapts intelligently** to different company structures and data conditions
3. **Provides complete observability** via Langfuse tracing
4. **Integrates seamlessly** with ERPNext's AI Assistant settings

### Key Results

**Pre-Close Checklist**:
```
Input:  Company + Period
Output: Complete validation report in ~30 seconds
        - Invoice status (submitted/draft/cancelled)
        - Payment reconciliation status
        - Outstanding receivables/payables with aging
        - Pending approvals by document type and amount
        - Actionable items with priority
```

**Full Month-End Close**:
```
Input:  Company + Period
Output: Complete financial close report in ~5 minutes
        - All pre-close validation items
        - Bank reconciliation summary
        - Financial statements (P&L, Balance Sheet)
        - Financial ratios (Current Ratio, D/E, ROA, etc.)
        - Intercompany reconciliation status
        - Executive summary with key insights
```

### The Differentiation

- ✅ **Real accounting workflows**
- ✅ **Production ERPNext integration** (actual Frappe API calls)
- ✅ **Complete observability** (every API call, every decision traced)
- ✅ **Handles complexity** (parallel execution, error handling, data validation)

---

<a name="architecture"></a>
## Architecture Overview

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                    AI Agent Framework                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  RunnableSequence (LangChain)                            │   │
│  │  - Orchestrates workflow execution                       │   │
│  │  - Manages dependencies between steps                    │   │
│  │  - Handles parallel vs sequential execution              │   │
│  └──────────────────────────────────────────────────────────┘   │
│                           │                                     │
│            ┌──────────────┼──────────────┐                      │
│            │              │              │                      │
│  ┌─────────▼────────┐ ┌───▼──────────┐ ┌─▼─────────────────┐    │
│  │ Runnable         │ │  Runnable    │  │  RunnableLambda  │    │
│  │ ParallelAgent    │ │  Sequential  │  │  (ERPNext Tools) │    │
│  │                  │ │  Agent       │  │                  │    │
│  │ - Invoice checks │ │  - Ordered   │  │  - Frappe API    │    │
│  │ - Payment checks │ │    workflow  │  │  - GL queries    │    │
│  │ - Outstanding    │ │  - Financial │  │  - DocType CRUD  │    │
│  │   items          │ │    stmts     │  │  - Reports       │    │
│  └──────────────────┘ └──────────────┘  └──────────────────┘    │
│                           │                                     │
│  ┌────────────────────────▼──────────────────────────────────┐  │
│  │  ChatOpenAI + ChatPromptTemplate                          │  │
│  │  - LLM decision-making layer                              │  │
│  │  - Interprets data and composes reports                   │  │
│  └───────────────────────────────────────────────────────────┘  │
│                           │                                     │
│  ┌────────────────────────▼──────────────────────────────────┐  │
│  │  Langfuse CallbackHandler                                 │  │
│  │  - Traces every step                                      │  │
│  │  - Captures tool calls, inputs, outputs                   │  │
│  │  - Measures latency, tokens, cost                         │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                           │
                           │ Configuration from
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│  ERPNext: AI Assistant Settings (Single DocType)                │
│  - LLM Provider (OpenAI / Anthropic / Local)                    │
│  - API Keys (encrypted)                                         │
│  - Model parameters                                             │
│  - Langfuse configuration (Public Key, Secret Key, Host)        │
└─────────────────────────────────────────────────────────────────┘
```

### Key Design Decisions

#### 1. **Parallel vs Sequential Execution**

```python
# Parallel: Run simultaneously for speed
parallel_checks = RunnableParallel({
    "invoices": check_sales_invoices + check_purchase_invoices,
    "payments": check_payment_reconciliation,
    "outstanding": analyze_outstanding_items,
    "approvals": check_pending_approvals
})

# Sequential: Run in order when steps depend on each other
sequential_workflow = RunnableSequence([
    pre_close_validation,      # Must complete first
    bank_reconciliation,        # Depends on pre-close
    financial_statements,       # Depends on bank rec
    intercompany_reconciliation, # Depends on financial stmts
    final_report_composition    # Depends on all above
])
```

**Why this matters**:
- Parallel execution cuts pre-close validation time from 2 minutes to 30 seconds
- Sequential execution ensures data consistency (no race conditions)

#### 2. **ERPNext Integration via RunnableLambda**

```python
class ERPNextTool(RunnableLambda):
    """Bridge between LangChain and ERPNext/Frappe"""

    def __init__(self, doctype: str, method: str):
        self.doctype = doctype
        self.method = method
        super().__init__(self._execute)

    def _execute(self, inputs: dict) -> dict:
        """Execute Frappe API call"""
        return frappe.get_all(
            self.doctype,
            filters=inputs.get("filters", {}),
            fields=inputs.get("fields", ["name"]),
            order_by=inputs.get("order_by", "creation desc"),
            limit=inputs.get("limit", 100)
        )

# Usage in agent
check_invoices_tool = ERPNextTool(
    doctype="Sales Invoice",
    method="get_all"
)
```

**Why this approach**:
- Clean separation of concerns (agent logic vs ERPNext API)
- Easy to mock for testing
- Automatically traced by Langfuse (it's a Runnable)

#### 3. **Centralized Configuration**

Rather than hardcoding credentials, I read from ERPNext settings:

```python
def initialize_agent():
    # Load from ERPNext Single DocType
    settings = frappe.get_single("AI Assistant Settings")

    # Configure Langfuse
    os.environ["LANGFUSE_PUBLIC_KEY"] = settings.langfuse_public_key
    os.environ["LANGFUSE_SECRET_KEY"] = settings.get_password("langfuse_secret_key")
    os.environ["LANGFUSE_HOST"] = settings.langfuse_host or "https://cloud.langfuse.com"

    # Configure LLM
    llm = ChatOpenAI(
        model=settings.model_name,
        temperature=settings.temperature,
        api_key=settings.get_password("api_key")
    )

    # Create Langfuse callback handler
    from langfuse.callback import CallbackHandler
    callback = CallbackHandler()

    return llm, callback
```

**Benefits**:
- No secrets in code
- Easy to switch between dev/prod
- Auditable (all changes tracked in ERPNext)

---

<a name="example-1"></a>
## Example 1: Pre-Close Checklist Agent

### What It Does

The Pre-Close Checklist agent validates that all prerequisites are met before attempting month-end close. It's the equivalent of a senior accountant's pre-close review checklist.

### Input

```python
{
    "company": "Noreli North (Demo)",
    "period": "October 2025",
    "date_range": {
        "from_date": "2025-10-01",
        "to_date": "2025-10-31"
    }
}
```

### Output

```
### Pre-Close Checklist for Noreli North (Demo) - October 2025

1. **Sales Invoices Status:**
   - Total Sales Invoices: 2
   - Submitted: 2 ✓
   - Draft: 0 ✓

2. **Purchase Invoices Status:**
   - Total Purchase Invoices: 4
   - Submitted: 3
   - Draft: 1 ⚠️
     - Action Required: Submit draft purchase invoice "ACC-PINV-2025-00012" ($500.00)

3. **Payment Reconciliation:**
   - All payments are reconciled. ✓

4. **Outstanding Items:**
   - Outstanding Receivables:
     - Total Amount: $91,800.00
     - Overdue Amount: $89,400.00
     - Top Customer: Grant Plastics Ltd.

   - Outstanding Payables:
     - Total Amount: $185,593.00
     - Overdue Amount: $185,593.00
     - Top Supplier: Summit Traders Ltd.

5. **Pending Approvals:**
   - Total Pending Approvals: 46
   - Total Amount: $21,111,411.00
   - Documents Affected: 3 DocTypes

### Summary:
- **Overall Readiness Status:** Not Ready ⚠️
- **Issues Requiring Attention:** 1
- **Estimated Time to Resolve:** Immediate (< 5 minutes)
- **Priority Action Item:**
  - Submit draft purchase invoice "ACC-PINV-2025-00012" ($500.00)
```

### Agent Implementation

```python
from langchain.schema.runnable import RunnableParallel, RunnableSequence
from langchain.chat_models import ChatOpenAI
from langchain.prompts import ChatPromptTemplate

def create_pre_close_checklist_agent(company: str, period: dict):
    """
    Creates an agent that performs pre-close validation checks
    """
    llm, langfuse_callback = initialize_agent()

    # Define parallel checks (run simultaneously)
    parallel_checks = RunnableParallel({
        "sales_invoices": check_sales_invoices_tool,
        "purchase_invoices": check_purchase_invoices_tool,
        "payment_reconciliation": check_payment_reconciliation_tool,
        "outstanding_items": analyze_outstanding_items_tool,
        "pending_approvals": check_pending_approvals_tool
    })

    # Define report composition prompt
    report_prompt = ChatPromptTemplate.from_template("""
    You are a senior accountant reviewing pre-close checklist results.

    Based on the following data, create a comprehensive pre-close checklist report:

    Sales Invoices: {sales_invoices}
    Purchase Invoices: {purchase_invoices}
    Payment Reconciliation: {payment_reconciliation}
    Outstanding Items: {outstanding_items}
    Pending Approvals: {pending_approvals}

    Format the report with:
    1. Status for each check (✓ if good, ⚠️ if attention needed)
    2. Specific action items if issues found
    3. Overall readiness assessment
    4. Priority ranking of issues

    Be specific: Include document numbers, amounts, and customer/supplier names.
    """)

    # Create sequential workflow
    agent = RunnableSequence([
        parallel_checks,           # Run all checks simultaneously
        report_prompt | llm        # Compose report with LLM
    ], callbacks=[langfuse_callback])

    # Execute agent
    result = agent.invoke({
        "company": company,
        "from_date": period["from_date"],
        "to_date": period["to_date"]
    })

    return result
```

### Langfuse Trace Analysis

When you run this agent and view the Langfuse trace, you see:

**Trace ID**: `bd990340e5278f55efc1b908d8139b49`

```
Pre-Close Checklist Agent
├── RunnableParallel (30.2s total)
│   ├── check_sales_invoices (8.1s)
│   │   ├── Tool Call: frappe.get_all
│   │   │   ├── Input: {doctype: "Sales Invoice", filters: {...}}
│   │   │   └── Output: [{name: "ACC-SINV-2025-00007", ...}, ...]
│   │   └── Result: 2 invoices, 2 submitted
│   │
│   ├── check_purchase_invoices (12.4s)
│   │   ├── Tool Call: frappe.get_all
│   │   │   ├── Input: {doctype: "Purchase Invoice", filters: {...}}
│   │   │   └── Output: [{name: "ACC-PINV-2025-00012", docstatus: 0}, ...]
│   │   └── Result: 4 invoices, 3 submitted, 1 draft ⚠️
│   │
│   ├── check_payment_reconciliation (6.3s)
│   ├── analyze_outstanding_items (15.8s)
│   └── check_pending_approvals (9.2s)
│
└── ChatOpenAI: Report Composition (4.1s)
    ├── Input Tokens: 2,847
    ├── Output Tokens: 542
    ├── Cost: $0.0124
    └── Model: gpt-4-turbo
```

**Key Insights from Trace**:
1. **Parallel execution saved ~20 seconds** (vs running sequentially)
2. **Draft invoice identified** in `check_purchase_invoices` step
3. **Total cost**: $0.0124 (very economical)
4. **Total time**: 34.3 seconds

---

<a name="example-2"></a>
## Example 2: Full Month-End Close Agent

### What It Does

The Month-End Close agent performs the complete financial close procedure, including all validation, reconciliation, financial statement generation, and reporting.

### Input

```python
{
    "company": "Noreli North (Demo)",
    "period": "October 2025",
    "date_range": {
        "from_date": "2025-10-01",
        "to_date": "2025-10-31"
    },
    "bank_accounts": ["Demo Bank Account - NND"],
    "include_intercompany": True
}
```

### Output

```
### Month-End Close Summary for Noreli North (Demo) - October 2025

1. **Pre-Close Validation**
   - Invoices: All invoices are submitted. ✓
   - Payment Reconciliation: All payments reconciled. ✓

2. **Bank Reconciliation**
   - Bank Account: Demo Bank Account - NND
   - Reconciliation Status: Complete ✓
   - Book Balance: $5,065,146.00
   - Bank Statement Balance: $5,065,146.00
   - Difference: $0.00

3. **Outstanding Items**
   - Receivables: $91,800.00 (Overdue: $89,400.00)
   - Payables: $185,593.00 (Overdue: $185,593.00)

4. **Pending Approvals**
   - Total Pending: 46 documents
   - Total Amount: $21,111,411.00

5. **Accrual Entries**
   - No accruals identified.
   - Verification: All invoices have correct accounting dimensions.

6. **Depreciation**
   - No active assets found for depreciation period.

7. **Financial Statements**

   **Profit & Loss Statement:**
   | Account | Amount |
   |---------|--------|
   | Revenue | $10,076,850.00 |
   | Cost of Goods Sold | $0.00 |
   | Gross Profit | $10,076,850.00 |
   | Operating Expenses | $104,250.00 |
   | **Net Profit** | **$9,972,600.00** |
   | **Profit Margin** | **98.97%** |

   **Balance Sheet:**
   | Category | Amount |
   |----------|--------|
   | Current Assets | $11,108,053.00 |
   | Fixed Assets | $93,200.00 |
   | **Total Assets** | **$11,201,253.00** |
   | Current Liabilities | $289,686.00 |
   | Long-term Liabilities | $89,200.00 |
   | **Total Liabilities** | **$378,886.00** |
   | Equity | $53,200.00 |
   | Retained Earnings | $10,769,167.00 |
   | **Total Equity** | **$10,822,367.00** |

   **Key Financial Ratios:**
   - Current Ratio: 38.36 (Excellent liquidity)
   - Debt-to-Equity Ratio: 7.12 (Moderate leverage)
   - Return on Assets (ROA): 89.03% (Outstanding performance)
   - Return on Equity (ROE): 92.14%

8. **Intercompany Reconciliation**
   - Status: Reconciliation attempted
   - Note: Counterparty company 'Noreli South' does not exist in system

### Overall Assessment:
✅ **Month-end close procedures completed successfully**
✅ **Financial statements generated and balanced**
⚠️ **Action Items:**
   - Review and resolve 46 pending approvals ($21.1M)
   - Follow up on overdue receivables ($89.4K)
   - Address intercompany setup for Noreli South

**Close Status**: COMPLETE
**Sign-off Ready**: Yes (with noted action items)
```

### Agent Implementation (Simplified)

```python
def create_month_end_close_agent(company: str, period: dict, bank_accounts: list):
    """
    Creates agent for complete month-end close workflow
    """
    llm, langfuse_callback = initialize_agent()

    # Step 1: Pre-close validation (from previous example)
    pre_close_agent = create_pre_close_checklist_agent(company, period)

    # Step 2: Bank reconciliation
    bank_rec_tool = ERPNextTool(doctype="Bank Reconciliation Tool", method="reconcile")

    # Step 3: Financial statements generation
    financial_statements_sequence = RunnableSequence([
        # Query GL for P&L accounts
        get_profit_loss_data,

        # Query GL for Balance Sheet accounts
        get_balance_sheet_data,

        # Calculate financial ratios
        calculate_financial_ratios,

        # Format into report
        format_financial_statements
    ])

    # Step 4: Intercompany reconciliation
    intercompany_tool = ERPNextTool(doctype="IC Match Group", method="run_matching")

    # Combine into complete workflow
    month_end_close_agent = RunnableSequence([
        {
            "pre_close": pre_close_agent,
            "bank_reconciliation": bank_rec_tool,
        },
        financial_statements_sequence,
        intercompany_tool,
        compose_final_report
    ], callbacks=[langfuse_callback])

    # Execute with metadata for Langfuse
    result = month_end_close_agent.invoke(
        {
            "company": company,
            "period": period,
            "bank_accounts": bank_accounts
        },
        config={
            "metadata": {
                "workflow": "month_end_close",
                "company": company,
                "period": f"{period['from_date']} to {period['to_date']}"
            }
        }
    )

    return result
```

### Langfuse Trace Analysis

**Trace ID**: `97c5a91fccf7071c947470497da6a1b5`

```
Month-End Close Agent (Total: 4m 52s)
├── RunnableSequence: Complete Workflow
│   │
│   ├── RunnableParallel: Pre-Close + Bank Rec (45.2s)
│   │   ├── Pre-Close Checklist Agent (34.3s)
│   │   │   └── [See detailed trace from Example 1]
│   │   │
│   │   └── Bank Reconciliation (28.7s)
│   │       ├── Tool: Get Bank Statement
│   │       ├── Tool: Get GL Entries for Bank Account
│   │       ├── Tool: Match Transactions
│   │       └── Result: Reconciled ✓
│   │
│   ├── RunnableSequence: Financial Statements (3m 48s)
│   │   │
│   │   ├── Get Profit & Loss Data (52.1s)
│   │   │   ├── Tool: frappe.db.sql (GL Entry query for revenue)
│   │   │   │   ├── Query: SELECT account, SUM(credit-debit) FROM...
│   │   │   │   └── Result: 18 revenue accounts, $10.08M total
│   │   │   │
│   │   │   └── Tool: frappe.db.sql (GL Entry query for expenses)
│   │   │       ├── Query: SELECT account, SUM(debit-credit) FROM...
│   │   │       └── Result: 7 expense accounts, $104.3K total
│   │   │
│   │   ├── Get Balance Sheet Data (1m 18.4s)
│   │   │   ├── Tool: Query Assets
│   │   │   ├── Tool: Query Liabilities
│   │   │   └── Tool: Query Equity
│   │   │
│   │   ├── Calculate Financial Ratios (8.2s)
│   │   │   ├── Current Ratio: 38.36
│   │   │   ├── Debt-to-Equity: 7.12
│   │   │   └── ROA: 89.03%
│   │   │
│   │   └── Format Financial Statements (1m 29.3s)
│   │       ├── ChatOpenAI: Generate P&L narrative
│   │       │   ├── Input Tokens: 4,182
│   │       │   ├── Output Tokens: 827
│   │       │   └── Cost: $0.0187
│   │       │
│   │       └── ChatOpenAI: Generate Balance Sheet narrative
│   │           ├── Input Tokens: 3,641
│   │           ├── Output Tokens: 694
│   │           └── Cost: $0.0164
│   │
│   ├── Intercompany Reconciliation (18.7s)
│   │   ├── Tool: Find Intercompany Transactions
│   │   └── Result: Counterparty not found (Noreli South)
│   │
│   └── Compose Final Report (1m 0.0s)
│       ├── ChatOpenAI: Executive Summary
│       │   ├── Input Tokens: 6,842
│       │   ├── Output Tokens: 1,204
│       │   ├── Cost: $0.0311
│       │   └── Model: gpt-4-turbo
│       │
│       └── Output: Complete Month-End Close Report
│
└── Metadata
    ├── Total Tool Calls: 47
    ├── Total Tokens: 18,934 (Input: 15,667, Output: 3,267)
    ├── Total Cost: $0.0876
    ├── Total Duration: 4m 52s
    └── Status: SUCCESS ✓
```

### Key Insights from Complex Trace

1. **Parallel execution** (Pre-Close + Bank Rec) saved significant time
2. **Most expensive step**: Financial statements composition ($0.0311)
3. **Most time-consuming step**: Financial statements (3m 48s)
4. **Optimization opportunity**: Could cache GL queries if running multiple times
5. **Error handling visible**: Intercompany reconciliation gracefully handled missing counterparty

---

<a name="langfuse-integration"></a>
## Langfuse Integration: How It Works

### Step 1: Configure ERPNext AI Assistant Settings

Create/update the `AI Assistant Settings` Single DocType with Langfuse fields:

**ai_assistant_settings.json** (DocType definition):
```json
{
    "doctype": "DocType",
    "name": "AI Assistant Settings",
    "issingle": 1,
    "fields": [
        {
            "fieldname": "langfuse_section",
            "label": "Langfuse Observability",
            "fieldtype": "Section Break"
        },
        {
            "fieldname": "enable_langfuse",
            "label": "Enable Langfuse Tracing",
            "fieldtype": "Check",
            "default": 1
        },
        {
            "fieldname": "langfuse_public_key",
            "label": "Langfuse Public Key",
            "fieldtype": "Data",
            "mandatory_depends_on": "enable_langfuse"
        },
        {
            "fieldname": "langfuse_secret_key",
            "label": "Langfuse Secret Key",
            "fieldtype": "Password",
            "mandatory_depends_on": "enable_langfuse"
        },
        {
            "fieldname": "langfuse_host",
            "label": "Langfuse Host",
            "fieldtype": "Data",
            "default": "https://cloud.langfuse.com",
            "description": "Use https://cloud.langfuse.com for cloud, or your self-hosted URL"
        }
    ]
}
```

### Step 2: Load Configuration in Agent

**agent_config.py**:
```python
import os
import frappe
from typing import Tuple
from langchain.chat_models import ChatOpenAI
from langfuse.callback import CallbackHandler

def get_ai_config() -> Tuple[ChatOpenAI, CallbackHandler]:
    """
    Load AI configuration from ERPNext settings
    Returns LLM instance and Langfuse callback handler
    """
    # Load Single DocType
    settings = frappe.get_single("AI Assistant Settings")

    if not settings.enable_langfuse:
        frappe.throw("Langfuse tracing is disabled in AI Assistant Settings")

    # Configure Langfuse environment
    os.environ["LANGFUSE_PUBLIC_KEY"] = settings.langfuse_public_key
    os.environ["LANGFUSE_SECRET_KEY"] = settings.get_password("langfuse_secret_key")
    os.environ["LANGFUSE_HOST"] = settings.langfuse_host

    # Initialize callback handler
    callback = CallbackHandler(
        # Optional: Add custom metadata
        tags=["erpnext", "financial-close"],
        session_id=frappe.session.user,
        user_id=frappe.session.user
    )

    # Initialize LLM
    llm = ChatOpenAI(
        model=settings.model_name or "gpt-4-turbo",
        temperature=settings.temperature or 0.1,
        api_key=settings.get_password("openai_api_key")
    )

    return llm, callback
```

### Step 3: Instrument Your Agent

**month_end_close_agent.py**:
```python
from langchain.schema.runnable import RunnableSequence, RunnableParallel
from agent_config import get_ai_config

def run_month_end_close(company: str, period: dict):
    """
    Execute month-end close with Langfuse tracing
    """
    # Get configured LLM and callback
    llm, langfuse_callback = get_ai_config()

    # Define your agent workflow
    agent = RunnableSequence([
        # ... your agent steps here ...
    ], callbacks=[langfuse_callback])  # ← This enables tracing!

    # Execute with metadata
    result = agent.invoke(
        {"company": company, "period": period},
        config={
            "metadata": {
                "workflow": "month_end_close",
                "company": company,
                "user": frappe.session.user
            },
            "tags": ["month-end-close", company]
        }
    )

    return result
```

### Step 4: View Traces in Langfuse

1. Run your agent
2. Log into Langfuse (cloud or self-hosted)
3. Navigate to **Traces** tab
4. Filter by:
   - Tags: `["erpnext", "month-end-close"]`
   - User: `frappe.session.user`
   - Time range: Last hour

You'll see:
- Complete execution tree
- Every tool call with inputs/outputs
- Token usage and costs per step
- Latency measurements
- Error traces (if any failures)

---

<a name="setup"></a>
## Setup Guide

### Prerequisites

- ERPNext v15+ (Frappe v15+)
- Python 3.10+
- OpenAI API key (or other LLM provider)
- Langfuse account (free tier available)

### Installation Steps

#### 1. Install Dependencies

```bash
# Navigate to your Frappe bench
cd frappe-bench

# Install Python packages
./env/bin/pip install langchain langchain-openai langfuse openai

# Or add to your app's requirements.txt
echo "langchain>=0.1.0" >> apps/your_app/requirements.txt
echo "langchain-openai>=0.0.5" >> apps/your_app/requirements.txt
echo "langfuse>=2.0.0" >> apps/your_app/requirements.txt
```

#### 2. Configure AI Assistant Settings

```bash
# Create the Single DocType (if not exists)
bench --site your-site migrate

# Set up Langfuse in ERPNext UI
# Navigate to: Settings → AI Assistant Settings
```

Fill in:
- **Langfuse Public Key**: Get from https://cloud.langfuse.com/settings
- **Langfuse Secret Key**: Get from https://cloud.langfuse.com/settings
- **Langfuse Host**: `https://cloud.langfuse.com` (or your self-hosted URL)

#### 3. Install the AI Agent Framework

```bash
# Clone the repository
cd apps
git clone https://github.com/[your-username]/erpnext-ai-agents.git

# Install the app
cd ../sites
bench --site your-site install-app erpnext-ai-agents

# Migrate
bench --site your-site migrate
```

#### 4. Test the Integration

```python
# In bench console
bench --site your-site console

# Test configuration
from erpnext_ai_agents.agent_config import get_ai_config
llm, callback = get_ai_config()
print(f"LLM Model: {llm.model_name}")
print(f"Langfuse Enabled: {callback is not None}")

# Test Pre-Close Checklist
from erpnext_ai_agents.pre_close_checklist import run_pre_close_checklist
result = run_pre_close_checklist(
    company="Your Company Name",
    period={"from_date": "2025-10-01", "to_date": "2025-10-31"}
)
print(result)
```

#### 5. Verify in Langfuse

1. Go to https://cloud.langfuse.com/traces
2. You should see a new trace for your test execution
3. Click into it to see the full execution tree

---

<a name="production"></a>
## Production Considerations

### 1. Error Handling

Always wrap agent execution in try/except:

```python
import frappe
from langchain.schema.runnable import RunnableSequence

def run_month_end_close_safe(company: str, period: dict):
    """
    Production-ready month-end close with error handling
    """
    try:
        llm, callback = get_ai_config()
        agent = create_month_end_close_agent(company, period)

        result = agent.invoke(
            {"company": company, "period": period},
            config={"metadata": {"source": "production"}}
        )

        # Log success
        frappe.logger().info(f"Month-end close completed for {company}")

        return {"status": "success", "result": result}

    except Exception as e:
        # Log error to Frappe
        frappe.log_error(
            message=f"Month-end close failed: {str(e)}\n{frappe.get_traceback()}",
            title=f"AI Agent Error: {company}"
        )

        # Langfuse will also capture the error in the trace

        return {
            "status": "error",
            "error": str(e),
            "message": "Month-end close failed. See Error Log for details."
        }
```

### 2. Cost Management

Monitor LLM costs via Langfuse:

```python
# Set budget alerts in Langfuse dashboard
# Settings → Cost Tracking → Set Alert Threshold

# Or implement in code:
def check_monthly_cost_limit():
    """Check if approaching monthly budget"""
    # Query Langfuse API for current month costs
    # (Implementation left as exercise)
    pass
```

### 3. Rate Limiting

Implement rate limiting for production:

```python
import time
from functools import wraps

def rate_limit(max_calls_per_minute=10):
    """Decorator to rate limit agent executions"""
    last_called = {}

    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            now = time.time()
            company = kwargs.get("company", args[0])

            if company in last_called:
                elapsed = now - last_called[company]
                if elapsed < 60 / max_calls_per_minute:
                    wait_time = (60 / max_calls_per_minute) - elapsed
                    frappe.throw(f"Rate limit exceeded. Try again in {wait_time:.1f}s")

            last_called[company] = now
            return func(*args, **kwargs)

        return wrapper
    return decorator

@rate_limit(max_calls_per_minute=5)
def run_month_end_close(company: str, period: dict):
    # ... implementation ...
    pass
```

### 4. Monitoring & Alerts

Set up alerts for:

- **Agent failures**: Email when agent execution fails
- **Cost spikes**: Alert if daily cost exceeds threshold
- **Latency issues**: Alert if execution time > 10 minutes
- **Data anomalies**: Alert if financial ratios are outside expected range

Example alert configuration in Langfuse:

```yaml
alerts:
  - name: "Month-End Close Failed"
    condition: "trace.status == 'ERROR' AND 'month-end-close' in trace.tags"
    action: "email"
    recipients: ["finance@company.com", "devops@company.com"]

  - name: "High Cost Warning"
    condition: "trace.cost > 1.00"
    action: "slack"
    channel: "#ai-monitoring"
```

### 5. Data Privacy

For sensitive financial data:

**Option 1**: Self-host Langfuse
```bash
# Use Docker Compose
git clone https://github.com/langfuse/langfuse
cd langfuse
docker-compose up -d

# Update AI Assistant Settings
Langfuse Host: https://your-internal-langfuse.company.com
```

**Option 2**: Mask sensitive data before logging
```python
def mask_sensitive_data(data: dict) -> dict:
    """Mask account numbers and customer names"""
    if "account" in data:
        data["account"] = data["account"][:4] + "****"
    if "customer_name" in data:
        data["customer_name"] = "***MASKED***"
    return data

# Apply before sending to Langfuse
# (Advanced: Use custom callback handler)
```

---

<a name="next-steps"></a>
## Next Steps

### Immediate Actions

**Watch the video tutorial**: [[YouTube link](https://youtu.be/O_RaNvtAr6g)]


### Coming in Part 3: Natural Language Queries

```python
# Instead of writing SQL:
query = "Show me all overdue receivables over $10,000 for Q4 2025"

# Agent handles it:
result = nl_query_agent.invoke(query)
# Returns: Formatted table with matching records
```

### Coming in Part 4: Autonomous Scheduling

```python
# Schedule month-end close to run automatically
schedule = {
    "workflow": "month_end_close",
    "frequency": "monthly",
    "day_of_month": 1,  # 1st of every month
    "time": "08:00",
    "companies": ["Company A", "Company B"],
    "notify": ["cfo@company.com", "controller@company.com"]
}
```

### Coming in Part 5: Multi-Company Consolidation

```python
# Run month-end close for all subsidiaries + consolidation
result = multi_company_close_agent.invoke({
    "parent_company": "Holding Corp",
    "subsidiaries": ["Sub A", "Sub B", "Sub C"],
    "eliminate_intercompany": True,
    "generate_consolidated_statements": True
})
```

---

## Resources

- **📹 Video Tutorial**: [[YouTube link]](https://youtu.be/O_RaNvtAr6g)
- **📖 Langfuse Documentation**: https://langfuse.com/docs
- **📖 ERPNext Documentation**: https://docs.erpnext.com

---

## FAQ

**Q: Does this work with self-hosted Langfuse?**
A: Yes! Just set the Langfuse Host in AI Assistant Settings to your self-hosted URL.

**Q: What LLM models are supported?**
A: OpenAI (GPT-4, GPT-3.5), Anthropic (Claude), and any OpenAI-compatible endpoint (local models via Ollama, etc.)

**Q: How much does it cost to run?**
A: For the examples shown:
- Pre-Close Checklist: ~$0.012 per execution
- Full Month-End Close: ~$0.088 per execution

With GPT-4-turbo. Costs are ~10x lower with GPT-3.5-turbo or local models.

**Q: Is this production-ready?**
A: Yes, with proper error handling, rate limiting, and monitoring (covered in Production Considerations section).

**Q: Can I customize the workflows?**
A: Absolutely! The framework is designed to be extended. Add your own tools, modify prompts, adjust the sequence.

**Q: What about data privacy?**
A: Use self-hosted Langfuse for complete data privacy, or implement data masking before logging (see Production Considerations).

---

## Contributing

I welcome contributions! Areas for improvement:

- [ ] Additional financial close checks (accruals, depreciation, etc.)
- [ ] Support for more ERP modules (inventory, manufacturing)
- [ ] Multi-language support (prompts in Spanish, German, etc.)
- [ ] Pre-built report templates
- [ ] Integration with other accounting systems
- [ ] Performance optimizations
